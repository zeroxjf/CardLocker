{"version":3,"sources":["/home/runner/work/storage/storage/packages/edge-config/dist/index.cjs","../src/index.ts","../package.json","../src/utils/tracing.ts","../src/utils/index.ts","../src/utils/fetch-with-cached-response.ts"],"names":[],"mappings":"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","file":"/home/runner/work/storage/storage/packages/edge-config/dist/index.cjs","sourcesContent":[null,"import { readFile } from '@vercel/edge-config-fs';\nimport { name as sdkName, version as sdkVersion } from '../package.json';\nimport {\n  assertIsKey,\n  assertIsKeys,\n  isEmptyKey,\n  ERRORS,\n  UnexpectedNetworkError,\n  hasOwnProperty,\n  parseConnectionString,\n  pick,\n} from './utils';\nimport type {\n  Connection,\n  EdgeConfigClient,\n  EdgeConfigItems,\n  EdgeConfigValue,\n  EmbeddedEdgeConfig,\n  EdgeConfigFunctionsOptions,\n} from './types';\nimport { fetchWithCachedResponse } from './utils/fetch-with-cached-response';\nimport { trace } from './utils/tracing';\n\nexport { setTracerProvider } from './utils/tracing';\n\nexport {\n  parseConnectionString,\n  type EdgeConfigClient,\n  type EdgeConfigItems,\n  type EdgeConfigValue,\n  type EmbeddedEdgeConfig,\n};\n\nconst jsonParseCache = new Map<string, unknown>();\n\nconst readFileTraced = trace(readFile, { name: 'readFile' });\nconst jsonParseTraced = trace(JSON.parse, { name: 'JSON.parse' });\n\nconst privateEdgeConfigSymbol = Symbol.for('privateEdgeConfig');\n\nconst cachedJsonParseTraced = trace(\n  (edgeConfigId: string, content: string) => {\n    const cached = jsonParseCache.get(edgeConfigId);\n    if (cached) return cached;\n\n    const parsed = jsonParseTraced(content) as unknown;\n\n    // freeze the object to avoid mutations of the return value of a \"get\" call\n    // from affecting the return value of future \"get\" calls\n    jsonParseCache.set(edgeConfigId, Object.freeze(parsed));\n    return parsed;\n  },\n  { name: 'cached JSON.parse' },\n);\n\n/**\n * Reads an Edge Config from the local file system.\n * This is used at runtime on serverless functions.\n */\nconst getFileSystemEdgeConfig = trace(\n  async function getFileSystemEdgeConfig(\n    connection: Connection,\n  ): Promise<EmbeddedEdgeConfig | null> {\n    // can't optimize non-vercel hosted edge configs\n    if (connection.type !== 'vercel') return null;\n    // can't use fs optimizations outside of lambda\n    if (!process.env.AWS_LAMBDA_FUNCTION_NAME) return null;\n\n    try {\n      const content = await readFileTraced(\n        `/opt/edge-config/${connection.id}.json`,\n        'utf-8',\n      );\n\n      return cachedJsonParseTraced(\n        connection.id,\n        content,\n      ) as EmbeddedEdgeConfig;\n    } catch {\n      return null;\n    }\n  },\n  {\n    name: 'getFileSystemEdgeConfig',\n  },\n);\n\n/**\n * Will return an embedded Edge Config object from memory,\n * but only when the `privateEdgeConfigSymbol` is in global scope.\n */\nconst getPrivateEdgeConfig = trace(\n  async function getPrivateEdgeConfig(\n    connection: Connection,\n  ): Promise<EmbeddedEdgeConfig | null> {\n    const privateEdgeConfig = Reflect.get(\n      globalThis,\n      privateEdgeConfigSymbol,\n    ) as\n      | {\n          get: (id: string) => Promise<EmbeddedEdgeConfig | null>;\n        }\n      | undefined;\n\n    if (\n      typeof privateEdgeConfig === 'object' &&\n      typeof privateEdgeConfig.get === 'function'\n    ) {\n      return privateEdgeConfig.get(connection.id);\n    }\n\n    return null;\n  },\n  {\n    name: 'getPrivateEdgeConfig',\n  },\n);\n\n/**\n * Returns a function to retrieve the entire Edge Config.\n * It'll keep the fetched Edge Config in memory, making subsequent calls fast,\n * while revalidating in the background.\n */\nfunction createGetInMemoryEdgeConfig(\n  shouldUseDevelopmentCache: boolean,\n  connection: Connection,\n  headers: Record<string, string>,\n  fetchCache: EdgeConfigClientOptions['cache'],\n): (\n  localOptions?: EdgeConfigFunctionsOptions,\n) => Promise<EmbeddedEdgeConfig | null> {\n  // Functions as cache to keep track of the Edge Config.\n  let embeddedEdgeConfigPromise: Promise<EmbeddedEdgeConfig | null> | null =\n    null;\n\n  // Promise that points to the most recent request.\n  // It'll ensure that subsequent calls won't make another fetch call,\n  // while one is still on-going.\n  // Will overwrite `embeddedEdgeConfigPromise` only when resolved.\n  let latestRequest: Promise<EmbeddedEdgeConfig | null> | null = null;\n\n  return trace(\n    (localOptions) => {\n      if (localOptions?.consistentRead || !shouldUseDevelopmentCache)\n        return Promise.resolve(null);\n\n      if (!latestRequest) {\n        latestRequest = fetchWithCachedResponse(\n          `${connection.baseUrl}/items?version=${connection.version}`,\n          {\n            headers: new Headers(headers),\n            cache: fetchCache,\n          },\n        ).then(async (res) => {\n          const digest = res.headers.get('x-edge-config-digest');\n          let body: EdgeConfigValue | undefined;\n\n          // We ignore all errors here and just proceed.\n          if (!res.ok) {\n            await consumeResponseBody(res);\n            body = res.cachedResponseBody as EdgeConfigValue | undefined;\n            if (!body) return null;\n          } else {\n            body = (await res.json()) as EdgeConfigItems;\n          }\n\n          return { digest, items: body } as EmbeddedEdgeConfig;\n        });\n\n        // Once the request is resolved, we set the proper config to the promise\n        // such that the next call will return the resolved value.\n        latestRequest.then(\n          (resolved) => {\n            embeddedEdgeConfigPromise = Promise.resolve(resolved);\n            latestRequest = null;\n          },\n          // Attach a `.catch` handler to this promise so that if it does throw,\n          // we don't get an unhandled promise rejection event. We unset the\n          // `latestRequest` so that the next call will make a new request.\n          () => {\n            embeddedEdgeConfigPromise = null;\n            latestRequest = null;\n          },\n        );\n      }\n\n      if (!embeddedEdgeConfigPromise) {\n        // If the `embeddedEdgeConfigPromise` is `null`, it means that there's\n        // no previous request, so we'll set the `latestRequest` to the current\n        // request.\n        embeddedEdgeConfigPromise = latestRequest;\n      }\n\n      return embeddedEdgeConfigPromise;\n    },\n    {\n      name: 'getInMemoryEdgeConfig',\n    },\n  );\n}\n\n/**\n * Uses `MAX_SAFE_INTEGER` as minimum updated at timestamp to force\n * a request to the origin.\n */\nfunction addConsistentReadHeader(headers: Headers): void {\n  headers.set('x-edge-config-min-updated-at', `${Number.MAX_SAFE_INTEGER}`);\n}\n\n/**\n * Reads the Edge Config from a local provider, if available,\n * to avoid Network requests.\n */\nasync function getLocalEdgeConfig(\n  connection: Connection,\n  options?: EdgeConfigFunctionsOptions,\n): Promise<EmbeddedEdgeConfig | null> {\n  if (options?.consistentRead) return null;\n\n  const edgeConfig =\n    (await getPrivateEdgeConfig(connection)) ||\n    (await getFileSystemEdgeConfig(connection));\n\n  return edgeConfig;\n}\n\n/**\n * This function reads the respone body\n *\n * Reading the response body serves two purposes\n *\n * 1) In Node.js it avoids memory leaks\n *\n * See https://github.com/nodejs/undici/blob/v5.21.2/README.md#garbage-collection\n * See https://github.com/node-fetch/node-fetch/issues/83\n *\n * 2) In Cloudflare it avoids running into a deadlock. They have a maximum number\n * of concurrent fetches (which is documented). Concurrency counts until the\n * body of a response is read. It is not uncommon to never read a response body\n * (e.g. if you only care about the status code). This can lead to deadlock as\n * fetches appear to never resolve.\n *\n * See https://developers.cloudflare.com/workers/platform/limits/#simultaneous-open-connections\n */\nasync function consumeResponseBody(res: Response): Promise<void> {\n  await res.arrayBuffer();\n}\n\ninterface EdgeConfigClientOptions {\n  /**\n   * The stale-if-error response directive indicates that the cache can reuse a\n   * stale response when an upstream server generates an error, or when the error\n   * is generated locally - for example due to a connection error.\n   *\n   * Any response with a status code of 500, 502, 503, or 504 is considered an error.\n   *\n   * Pass a negative number, 0, or false to turn disable stale-if-error semantics.\n   *\n   * The time is supplied in seconds. Defaults to one week (`604800`).\n   */\n  staleIfError?: number | false;\n  /**\n   * In development, a stale-while-revalidate cache is employed as the default caching strategy.\n   *\n   * This cache aims to deliver speedy Edge Config reads during development, though it comes\n   * at the cost of delayed visibility for updates to Edge Config. Typically, you may need to\n   * refresh twice to observe these changes as the stale value is replaced.\n   *\n   * This cache is not used in preview or production deployments as superior optimisations are applied there.\n   */\n  disableDevelopmentCache?: boolean;\n\n  /**\n   * Sets a `cache` option on the `fetch` call made by Edge Config.\n   *\n   * Unlike Next.js, this defaults to `no-store`, as you most likely want to use Edge Config dynamically.\n   */\n  cache?: 'no-store' | 'force-cache';\n}\n\n/**\n * Create an Edge Config client.\n *\n * The client has multiple methods which allow you to read the Edge Config.\n *\n * If you need to programmatically write to an Edge Config, check out the [Update your Edge Config items](https://vercel.com/docs/storage/edge-config/vercel-api#update-your-edge-config-items) section.\n *\n * @param connectionString - A connection string. Usually you'd pass in `process.env.EDGE_CONFIG` here, which contains a connection string.\n * @returns An Edge Config Client instance\n */\nexport const createClient = trace(\n  function createClient(\n    connectionString: string | undefined,\n    options: EdgeConfigClientOptions = {\n      staleIfError: 604800 /* one week */,\n      cache: 'no-store',\n    },\n  ): EdgeConfigClient {\n    if (!connectionString)\n      throw new Error('@vercel/edge-config: No connection string provided');\n\n    const connection = parseConnectionString(connectionString);\n\n    if (!connection)\n      throw new Error(\n        '@vercel/edge-config: Invalid connection string provided',\n      );\n\n    const edgeConfigId = connection.id;\n    const baseUrl = connection.baseUrl;\n    const version = connection.version; // version of the edge config read access api we talk to\n    const headers: Record<string, string> = {\n      Authorization: `Bearer ${connection.token}`,\n    };\n\n    // eslint-disable-next-line @typescript-eslint/prefer-optional-chain -- [@vercel/style-guide@5 migration]\n    if (typeof process !== 'undefined' && process.env.VERCEL_ENV)\n      headers['x-edge-config-vercel-env'] = process.env.VERCEL_ENV;\n\n    if (typeof sdkName === 'string' && typeof sdkVersion === 'string')\n      headers['x-edge-config-sdk'] = `${sdkName}@${sdkVersion}`;\n\n    if (typeof options.staleIfError === 'number' && options.staleIfError > 0)\n      headers['cache-control'] = `stale-if-error=${options.staleIfError}`;\n\n    const fetchCache = options.cache || 'no-store';\n\n    /**\n     * While in development we use SWR-like behavior for the api client to\n     * reduce latency.\n     */\n    const shouldUseDevelopmentCache =\n      !options.disableDevelopmentCache &&\n      process.env.NODE_ENV === 'development' &&\n      process.env.EDGE_CONFIG_DISABLE_DEVELOPMENT_SWR !== '1';\n\n    const getInMemoryEdgeConfig = createGetInMemoryEdgeConfig(\n      shouldUseDevelopmentCache,\n      connection,\n      headers,\n      fetchCache,\n    );\n\n    const api: Omit<EdgeConfigClient, 'connection'> = {\n      get: trace(\n        async function get<T = EdgeConfigValue>(\n          key: string,\n          localOptions?: EdgeConfigFunctionsOptions,\n        ): Promise<T | undefined> {\n          const localEdgeConfig =\n            (await getInMemoryEdgeConfig(localOptions)) ||\n            (await getLocalEdgeConfig(connection, localOptions));\n\n          assertIsKey(key);\n          if (isEmptyKey(key)) return undefined;\n\n          if (localEdgeConfig) {\n            // We need to return a clone of the value so users can't modify\n            // our original value, and so the reference changes.\n            //\n            // This makes it consistent with the real API.\n            return Promise.resolve(localEdgeConfig.items[key] as T);\n          }\n\n          const localHeaders = new Headers(headers);\n          if (localOptions?.consistentRead)\n            addConsistentReadHeader(localHeaders);\n\n          return fetchWithCachedResponse(\n            `${baseUrl}/item/${key}?version=${version}`,\n            {\n              headers: localHeaders,\n              cache: fetchCache,\n            },\n          ).then<T | undefined, undefined>(async (res) => {\n            if (res.ok) return res.json();\n            await consumeResponseBody(res);\n\n            if (res.status === 401) throw new Error(ERRORS.UNAUTHORIZED);\n            if (res.status === 404) {\n              // if the x-edge-config-digest header is present, it means\n              // the edge config exists, but the item does not\n              if (res.headers.has('x-edge-config-digest')) return undefined;\n              // if the x-edge-config-digest header is not present, it means\n              // the edge config itself does not exist\n              throw new Error(ERRORS.EDGE_CONFIG_NOT_FOUND);\n            }\n            if (res.cachedResponseBody !== undefined)\n              return res.cachedResponseBody as T;\n            throw new UnexpectedNetworkError(res);\n          });\n        },\n        { name: 'get', isVerboseTrace: false, attributes: { edgeConfigId } },\n      ),\n      has: trace(\n        async function has(\n          key,\n          localOptions?: EdgeConfigFunctionsOptions,\n        ): Promise<boolean> {\n          const localEdgeConfig =\n            (await getInMemoryEdgeConfig(localOptions)) ||\n            (await getLocalEdgeConfig(connection, localOptions));\n\n          assertIsKey(key);\n          if (isEmptyKey(key)) return false;\n\n          if (localEdgeConfig) {\n            return Promise.resolve(hasOwnProperty(localEdgeConfig.items, key));\n          }\n\n          const localHeaders = new Headers(headers);\n          if (localOptions?.consistentRead)\n            addConsistentReadHeader(localHeaders);\n\n          // this is a HEAD request anyhow, no need for fetchWithCachedResponse\n          return fetch(`${baseUrl}/item/${key}?version=${version}`, {\n            method: 'HEAD',\n            headers: localHeaders,\n            cache: fetchCache,\n          }).then((res) => {\n            if (res.status === 401) throw new Error(ERRORS.UNAUTHORIZED);\n            if (res.status === 404) {\n              // if the x-edge-config-digest header is present, it means\n              // the edge config exists, but the item does not\n              if (res.headers.has('x-edge-config-digest')) return false;\n              // if the x-edge-config-digest header is not present, it means\n              // the edge config itself does not exist\n              throw new Error(ERRORS.EDGE_CONFIG_NOT_FOUND);\n            }\n            if (res.ok) return true;\n            throw new UnexpectedNetworkError(res);\n          });\n        },\n        { name: 'has', isVerboseTrace: false, attributes: { edgeConfigId } },\n      ),\n      getAll: trace(\n        async function getAll<T = EdgeConfigItems>(\n          keys?: (keyof T)[],\n          localOptions?: EdgeConfigFunctionsOptions,\n        ): Promise<T> {\n          const localEdgeConfig =\n            (await getInMemoryEdgeConfig(localOptions)) ||\n            (await getLocalEdgeConfig(connection, localOptions));\n\n          if (localEdgeConfig) {\n            if (keys === undefined) {\n              return Promise.resolve(localEdgeConfig.items as T);\n            }\n\n            assertIsKeys(keys);\n            return Promise.resolve(pick(localEdgeConfig.items, keys) as T);\n          }\n\n          if (Array.isArray(keys)) assertIsKeys(keys);\n\n          const search = Array.isArray(keys)\n            ? new URLSearchParams(\n                keys\n                  .filter((key) => typeof key === 'string' && !isEmptyKey(key))\n                  .map((key) => ['key', key] as [string, string]),\n              ).toString()\n            : null;\n\n          // empty search keys array was given,\n          // so skip the request and return an empty object\n          if (search === '') return Promise.resolve({} as T);\n\n          const localHeaders = new Headers(headers);\n          if (localOptions?.consistentRead)\n            addConsistentReadHeader(localHeaders);\n\n          return fetchWithCachedResponse(\n            `${baseUrl}/items?version=${version}${\n              search === null ? '' : `&${search}`\n            }`,\n            {\n              headers: localHeaders,\n              cache: fetchCache,\n            },\n          ).then<T>(async (res) => {\n            if (res.ok) return res.json();\n            await consumeResponseBody(res);\n\n            if (res.status === 401) throw new Error(ERRORS.UNAUTHORIZED);\n            // the /items endpoint never returns 404, so if we get a 404\n            // it means the edge config itself did not exist\n            if (res.status === 404)\n              throw new Error(ERRORS.EDGE_CONFIG_NOT_FOUND);\n            if (res.cachedResponseBody !== undefined)\n              return res.cachedResponseBody as T;\n            throw new UnexpectedNetworkError(res);\n          });\n        },\n        { name: 'getAll', isVerboseTrace: false, attributes: { edgeConfigId } },\n      ),\n      digest: trace(\n        async function digest(\n          localOptions?: EdgeConfigFunctionsOptions,\n        ): Promise<string> {\n          const localEdgeConfig =\n            (await getInMemoryEdgeConfig(localOptions)) ||\n            (await getLocalEdgeConfig(connection, localOptions));\n\n          if (localEdgeConfig) {\n            return Promise.resolve(localEdgeConfig.digest);\n          }\n\n          const localHeaders = new Headers(headers);\n          if (localOptions?.consistentRead)\n            addConsistentReadHeader(localHeaders);\n\n          return fetchWithCachedResponse(\n            `${baseUrl}/digest?version=${version}`,\n            {\n              headers: localHeaders,\n              cache: fetchCache,\n            },\n          ).then(async (res) => {\n            if (res.ok) return res.json() as Promise<string>;\n            await consumeResponseBody(res);\n\n            if (res.cachedResponseBody !== undefined)\n              return res.cachedResponseBody as string;\n            throw new UnexpectedNetworkError(res);\n          });\n        },\n        { name: 'digest', isVerboseTrace: false, attributes: { edgeConfigId } },\n      ),\n    };\n\n    return { ...api, connection };\n  },\n  {\n    name: 'createClient',\n  },\n);\n\nlet defaultEdgeConfigClient: EdgeConfigClient;\n\n// lazy init fn so the default edge config does not throw in case\n// process.env.EDGE_CONFIG is not defined and its methods are never used.\nfunction init(): void {\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- [@vercel/style-guide@5 migration]\n  if (!defaultEdgeConfigClient) {\n    defaultEdgeConfigClient = createClient(process.env.EDGE_CONFIG);\n  }\n}\n\n/**\n * Reads a single item from the default Edge Config.\n *\n * This is a convenience method which reads the default Edge Config.\n * It is conceptually similar to `createClient(process.env.EDGE_CONFIG).get()`.\n *\n * @see {@link EdgeConfigClient.get}\n * @param key - the key to read\n * @returns the value stored under the given key, or undefined\n */\nexport const get: EdgeConfigClient['get'] = (...args) => {\n  init();\n  return defaultEdgeConfigClient.get(...args);\n};\n\n/**\n * Reads multiple or all values.\n *\n * This is a convenience method which reads the default Edge Config.\n * It is conceptually similar to `createClient(process.env.EDGE_CONFIG).getAll()`.\n *\n * @see {@link EdgeConfigClient.getAll}\n * @param keys - the keys to read\n * @returns the value stored under the given key, or undefined\n */\nexport const getAll: EdgeConfigClient['getAll'] = (...args) => {\n  init();\n  return defaultEdgeConfigClient.getAll(...args);\n};\n\n/**\n * Check if a given key exists in the Edge Config.\n *\n * This is a convenience method which reads the default Edge Config.\n * It is conceptually similar to `createClient(process.env.EDGE_CONFIG).has()`.\n *\n * @see {@link EdgeConfigClient.has}\n * @param key - the key to check\n * @returns true if the given key exists in the Edge Config.\n */\nexport const has: EdgeConfigClient['has'] = (...args) => {\n  init();\n  return defaultEdgeConfigClient.has(...args);\n};\n\n/**\n * Get the digest of the Edge Config.\n *\n * This is a convenience method which reads the default Edge Config.\n * It is conceptually similar to `createClient(process.env.EDGE_CONFIG).digest()`.\n *\n * @see {@link EdgeConfigClient.digest}\n * @returns The digest of the Edge Config.\n */\nexport const digest: EdgeConfigClient['digest'] = (...args) => {\n  init();\n  return defaultEdgeConfigClient.digest(...args);\n};\n\n/**\n * Safely clones a read-only Edge Config object and makes it mutable.\n */\nexport function clone<T = EdgeConfigValue>(edgeConfigValue: T): T {\n  // Use JSON.parse and JSON.stringify instead of anything else due to\n  // the value possibly being a Proxy object.\n  return JSON.parse(JSON.stringify(edgeConfigValue)) as T;\n}\n","{\n  \"name\": \"@vercel/edge-config\",\n  \"version\": \"1.4.0\",\n  \"description\": \"Ultra-low latency data at the edge\",\n  \"homepage\": \"https://vercel.com\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/vercel/storage.git\",\n    \"directory\": \"packages/edge-config\"\n  },\n  \"license\": \"Apache-2.0\",\n  \"sideEffects\": false,\n  \"type\": \"module\",\n  \"exports\": {\n    \"import\": \"./dist/index.js\",\n    \"require\": \"./dist/index.cjs\"\n  },\n  \"main\": \"./dist/index.cjs\",\n  \"module\": \"./dist/index.js\",\n  \"files\": [\n    \"dist\"\n  ],\n  \"scripts\": {\n    \"build\": \"tsup\",\n    \"dev\": \"tsup --watch --clean=false\",\n    \"lint\": \"eslint --max-warnings=0 .\",\n    \"prepublishOnly\": \"pnpm run build\",\n    \"prettier-check\": \"prettier --check .\",\n    \"publint\": \"npx publint\",\n    \"test\": \"pnpm run test:node && pnpm run test:edge && pnpm run test:common\",\n    \"test:common\": \"jest --env @edge-runtime/jest-environment .common.test.ts && jest --env node .common.test.ts\",\n    \"test:edge\": \"jest --env @edge-runtime/jest-environment .edge.test.ts\",\n    \"test:node\": \"jest --env node .node.test.ts\",\n    \"type-check\": \"tsc --noEmit\"\n  },\n  \"jest\": {\n    \"preset\": \"ts-jest\",\n    \"setupFiles\": [\n      \"<rootDir>/jest/setup.js\"\n    ],\n    \"testEnvironment\": \"node\"\n  },\n  \"dependencies\": {\n    \"@vercel/edge-config-fs\": \"workspace:*\"\n  },\n  \"devDependencies\": {\n    \"@changesets/cli\": \"2.27.9\",\n    \"@edge-runtime/jest-environment\": \"2.3.10\",\n    \"@edge-runtime/types\": \"2.2.9\",\n    \"@types/jest\": \"29.5.13\",\n    \"@types/node\": \"22.7.3\",\n    \"eslint\": \"8.56.0\",\n    \"eslint-config-custom\": \"workspace:*\",\n    \"jest\": \"29.7.0\",\n    \"jest-fetch-mock\": \"3.0.3\",\n    \"node-domexception\": \"2.0.1\",\n    \"prettier\": \"3.3.3\",\n    \"ts-jest\": \"29.2.5\",\n    \"tsconfig\": \"workspace:*\",\n    \"tsup\": \"8.3.0\",\n    \"typescript\": \"5.6.2\"\n  },\n  \"peerDependencies\": {\n    \"@opentelemetry/api\": \"^1.7.0\"\n  },\n  \"peerDependenciesMeta\": {\n    \"@opentelemetry/api\": {\n      \"optional\": true\n    }\n  },\n  \"engines\": {\n    \"node\": \">=14.6\"\n  }\n}\n","import type { Tracer, Attributes, TracerProvider } from '@opentelemetry/api';\nimport { name as pkgName, version } from '../../package.json';\n\n// Use a symbol to avoid having global variable that is scoped to this file,\n// as it can lead to issues with cjs and mjs being used at the same time.\nconst edgeConfigTraceSymbol = Symbol.for('@vercel/edge-config:global-trace');\n\n/**\n * Allows setting the `@opentelemetry/api` tracer provider to generate traces\n * for Edge Config related operations.\n */\nexport function setTracerProvider(tracer: TracerProvider): void {\n  Reflect.set(globalThis, edgeConfigTraceSymbol, tracer);\n}\n\nfunction getTracer(): Tracer | undefined {\n  const maybeTraceApi = Reflect.get(globalThis, edgeConfigTraceSymbol) as\n    | undefined\n    | TracerProvider;\n  return maybeTraceApi?.getTracer(pkgName, version);\n}\n\nfunction isPromise<T>(p: unknown): p is Promise<T> {\n  return (\n    p !== null &&\n    typeof p === 'object' &&\n    'then' in p &&\n    typeof p.then === 'function'\n  );\n}\n\n/* eslint-disable @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-explicit-any -- bc */\nexport function trace<F extends (...args: any) => any>(\n  fn: F,\n  options: {\n    name: string;\n    /** Defaults to `true`. If set to `false`, it'll trace regardless of `EDGE_CONFIG_TRACE_VERBOSE`. */\n    isVerboseTrace?: boolean;\n    attributes?: Attributes;\n    attributesSuccess?: (\n      result: ReturnType<F> extends PromiseLike<infer U> ? U : ReturnType<F>,\n    ) => Attributes;\n    attributesError?: (error: Error) => Attributes;\n  } = {\n    name: fn.name,\n  },\n): F {\n  const traced = function (this: unknown, ...args: unknown[]): unknown {\n    const tracer = getTracer();\n    if (!tracer) return fn.apply(this, args);\n\n    const shouldTrace =\n      process.env.EDGE_CONFIG_TRACE_VERBOSE === 'true' ||\n      options.isVerboseTrace === false;\n    if (!shouldTrace) return fn.apply(this, args);\n\n    return tracer.startActiveSpan(options.name, (span) => {\n      if (options.attributes) span.setAttributes(options.attributes);\n\n      try {\n        const result = fn.apply(this, args);\n\n        if (isPromise(result)) {\n          result\n            .then((value) => {\n              if (options.attributesSuccess) {\n                span.setAttributes(\n                  options.attributesSuccess(\n                    value as ReturnType<F> extends PromiseLike<infer U>\n                      ? U\n                      : ReturnType<F>,\n                  ),\n                );\n              }\n\n              span.setStatus({ code: 1 }); // 1 = Ok\n              span.end();\n            })\n            .catch((error) => {\n              if (options.attributesError) {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument -- k\n                span.setAttributes(options.attributesError(error));\n              }\n\n              span.setStatus({\n                code: 2, // 2 = Error\n                message: error instanceof Error ? error.message : undefined,\n              });\n\n              span.end();\n            });\n        } else {\n          if (options.attributesSuccess) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument -- k\n            span.setAttributes(options.attributesSuccess(result));\n          }\n\n          span.setStatus({ code: 1 }); // 1 = Ok\n          span.end();\n        }\n\n        return result as unknown;\n      } catch (error: any) {\n        if (options.attributesError) {\n          span.setAttributes(options.attributesError(error as Error));\n        }\n\n        span.setStatus({\n          code: 2, // 2 = Error\n          message: error instanceof Error ? error.message : undefined,\n        });\n\n        span.end();\n\n        throw error;\n      }\n    });\n  };\n\n  return traced as unknown as F;\n}\n/* eslint-enable @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-explicit-any -- k */\n","import type { Connection } from '../types';\nimport { trace } from './tracing';\n\nexport const ERRORS = {\n  UNAUTHORIZED: '@vercel/edge-config: Unauthorized',\n  EDGE_CONFIG_NOT_FOUND: '@vercel/edge-config: Edge Config not found',\n};\n\nexport class UnexpectedNetworkError extends Error {\n  constructor(res: Response) {\n    super(\n      `@vercel/edge-config: Unexpected error due to response with status code ${res.status}`,\n    );\n  }\n}\n\n/**\n * Checks if an object has a property\n */\nexport function hasOwnProperty<X, Y extends PropertyKey>(\n  obj: X,\n  prop: Y,\n): obj is X & Record<Y, unknown> {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nexport function pick<T, K extends keyof T>(obj: T, keys: K[]): Pick<T, K> {\n  const ret: Partial<T> = {};\n  keys.forEach((key) => {\n    ret[key] = obj[key];\n  });\n  return ret as Pick<T, K>;\n}\n\nexport function assertIsKey(key: unknown): asserts key is string {\n  if (typeof key !== 'string') {\n    throw new Error('@vercel/edge-config: Expected key to be a string');\n  }\n}\n\nexport function isEmptyKey(key: string): boolean {\n  return key.trim() === '';\n}\n\nexport function assertIsKeys(keys: unknown): asserts keys is string[] {\n  if (!Array.isArray(keys) || keys.some((key) => typeof key !== 'string')) {\n    throw new Error(\n      '@vercel/edge-config: Expected keys to be an array of string',\n    );\n  }\n}\n\n/**\n * Creates a deep clone of an object.\n */\nexport const clone = trace(\n  function clone<T>(value: T): T {\n    // only available since node v17.0.0\n    if (typeof structuredClone === 'function') return structuredClone<T>(value);\n\n    // poor man's polyfill for structuredClone\n    if (value === undefined) return value;\n    return JSON.parse(JSON.stringify(value)) as T;\n  },\n  { name: 'clone' },\n);\n\n/**\n * Parses internal edge config connection strings\n *\n * Internal edge config connection strings are those which are native to Vercel.\n *\n * Internal Edge Config Connection Strings look like this:\n * https://edge-config.vercel.com/<edgeConfigId>?token=<token>\n */\nfunction parseVercelConnectionStringFromUrl(text: string): Connection | null {\n  try {\n    const url = new URL(text);\n    if (url.host !== 'edge-config.vercel.com') return null;\n    if (url.protocol !== 'https:') return null;\n    if (!url.pathname.startsWith('/ecfg')) return null;\n\n    const id = url.pathname.split('/')[1];\n    if (!id) return null;\n\n    const token = url.searchParams.get('token');\n    if (!token || token === '') return null;\n\n    return {\n      type: 'vercel',\n      baseUrl: `https://edge-config.vercel.com/${id}`,\n      id,\n      version: '1',\n      token,\n    };\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Parses a connection string with the following format:\n * `edge-config:id=ecfg_abcd&token=xxx`\n */\nfunction parseConnectionFromQueryParams(text: string): Connection | null {\n  try {\n    if (!text.startsWith('edge-config:')) return null;\n    const params = new URLSearchParams(text.slice(12));\n\n    const id = params.get('id');\n    const token = params.get('token');\n\n    if (!id || !token) return null;\n\n    return {\n      type: 'vercel',\n      baseUrl: `https://edge-config.vercel.com/${id}`,\n      id,\n      version: '1',\n      token,\n    };\n  } catch {\n    // no-op\n  }\n\n  return null;\n}\n\n/**\n * Parses info contained in connection strings.\n *\n * This works with the vercel-provided connection strings, but it also\n * works with custom connection strings.\n *\n * The reason we support custom connection strings is that it makes testing\n * edge config really straightforward. Users can provide  connection strings\n * pointing to their own servers and then either have a custom server\n * return the desired values or even intercept requests with something like\n * msw.\n *\n * To allow interception we need a custom connection string as the\n * edge-config.vercel.com connection string might not always go over\n * the network, so msw would not have a chance to intercept.\n */\n/**\n * Parses external edge config connection strings\n *\n * External edge config connection strings are those which are foreign to Vercel.\n *\n * External Edge Config Connection Strings look like this:\n * - https://example.com/?id=<edgeConfigId>&token=<token>\n * - https://example.com/<edgeConfigId>?token=<token>\n */\nfunction parseExternalConnectionStringFromUrl(\n  connectionString: string,\n): Connection | null {\n  try {\n    const url = new URL(connectionString);\n\n    let id: string | null = url.searchParams.get('id');\n    const token = url.searchParams.get('token');\n    const version = url.searchParams.get('version') || '1';\n\n    // try to determine id based on pathname if it wasn't provided explicitly\n    if (!id || url.pathname.startsWith('/ecfg_')) {\n      id = url.pathname.split('/')[1] || null;\n    }\n\n    if (!id || !token) return null;\n\n    // remove all search params for use as baseURL\n    url.search = '';\n\n    // try to parse as external connection string\n    return {\n      type: 'external',\n      baseUrl: url.toString(),\n      id,\n      token,\n      version,\n    };\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Parse the edgeConfigId and token from an Edge Config Connection String.\n *\n * Edge Config Connection Strings usually look like one of the following:\n *  - https://edge-config.vercel.com/<edgeConfigId>?token=<token>\n *  - edge-config:id=<edgeConfigId>&token=<token>\n *\n * @param text - A potential Edge Config Connection String\n * @returns The connection parsed from the given Connection String or null.\n */\nexport function parseConnectionString(\n  connectionString: string,\n): Connection | null {\n  return (\n    parseConnectionFromQueryParams(connectionString) ||\n    parseVercelConnectionStringFromUrl(connectionString) ||\n    parseExternalConnectionStringFromUrl(connectionString)\n  );\n}\n","import { trace } from './tracing';\n\ninterface CachedResponseEntry {\n  etag: string;\n  response: string;\n  headers: Record<string, string>;\n  status: number;\n  time: number;\n}\n\ntype FetchOptions = Omit<RequestInit, 'headers'> & { headers?: Headers };\n\ninterface ResponseWithCachedResponse extends Response {\n  cachedResponseBody?: unknown;\n}\n\n/**\n * Creates a new response based on a cache entry\n */\nfunction createResponse(\n  cachedResponseEntry: CachedResponseEntry,\n): ResponseWithCachedResponse {\n  return new Response(cachedResponseEntry.response, {\n    headers: {\n      ...cachedResponseEntry.headers,\n      Age: String(\n        // age header may not be 0 when serving stale content, must be >= 1\n        Math.max(1, Math.floor((Date.now() - cachedResponseEntry.time) / 1000)),\n      ),\n    },\n    status: cachedResponseEntry.status,\n  });\n}\n\n/**\n * Used for bad responses like 500s\n */\nfunction createHandleStaleIfError(\n  cachedResponseEntry: CachedResponseEntry,\n  staleIfError: number | null,\n) {\n  return function handleStaleIfError(\n    response: ResponseWithCachedResponse,\n  ): ResponseWithCachedResponse {\n    switch (response.status) {\n      case 500:\n      case 502:\n      case 503:\n      case 504:\n        return typeof staleIfError === 'number' &&\n          cachedResponseEntry.time < Date.now() + staleIfError * 1000\n          ? createResponse(cachedResponseEntry)\n          : response;\n      default:\n        return response;\n    }\n  };\n}\n\n/**\n * Used on network errors which end up throwing\n */\nfunction createHandleStaleIfErrorException(\n  cachedResponseEntry: CachedResponseEntry,\n  staleIfError: number | null,\n) {\n  return function handleStaleIfError(\n    reason: unknown,\n  ): ResponseWithCachedResponse {\n    if (\n      typeof staleIfError === 'number' &&\n      cachedResponseEntry.time < Date.now() + staleIfError * 1000\n    ) {\n      return createResponse(cachedResponseEntry);\n    }\n    throw reason;\n  };\n}\n\n/**\n * A cache of request urls & auth headers and the resulting responses.\n *\n * This cache does not use Response instances as the cache value as reusing\n * responses across requests leads to issues in Cloudflare Workers.\n */\nexport const cache = new Map<string, CachedResponseEntry>();\n\nfunction extractStaleIfError(cacheControlHeader: string | null): number | null {\n  if (!cacheControlHeader) return null;\n  const matched = /stale-if-error=(?<staleIfError>\\d+)/i.exec(\n    cacheControlHeader,\n  );\n  return matched?.groups ? Number(matched.groups.staleIfError) : null;\n}\n\n/**\n * This is similar to fetch, but it also implements ETag semantics, and\n * it implmenets stale-if-error semantics.\n */\nexport const fetchWithCachedResponse = trace(\n  async function fetchWithCachedResponse(\n    url: string,\n    options: FetchOptions = {},\n  ): Promise<ResponseWithCachedResponse> {\n    const { headers: customHeaders = new Headers(), ...customOptions } =\n      options;\n    const authHeader = customHeaders.get('Authorization');\n    const cacheKey = `${url},${authHeader || ''}`;\n\n    const cachedResponseEntry = cache.get(cacheKey);\n\n    if (cachedResponseEntry) {\n      const { etag, response: cachedResponse } = cachedResponseEntry;\n      const headers = new Headers(customHeaders);\n      headers.set('If-None-Match', etag);\n\n      const staleIfError = extractStaleIfError(headers.get('Cache-Control'));\n\n      const res: ResponseWithCachedResponse = await fetch(url, {\n        ...customOptions,\n        headers,\n      }).then(\n        createHandleStaleIfError(cachedResponseEntry, staleIfError),\n        createHandleStaleIfErrorException(cachedResponseEntry, staleIfError),\n      );\n\n      if (res.status === 304) {\n        res.cachedResponseBody = JSON.parse(cachedResponse);\n        return res;\n      }\n\n      const newETag = res.headers.get('ETag');\n      if (res.ok && newETag)\n        cache.set(cacheKey, {\n          etag: newETag,\n          response: await res.clone().text(),\n          headers: Object.fromEntries(res.headers.entries()),\n          status: res.status,\n          time: Date.now(),\n        });\n      return res;\n    }\n\n    const res = await fetch(url, options);\n    const etag = res.headers.get('ETag');\n    if (res.ok && etag) {\n      cache.set(cacheKey, {\n        etag,\n        response: await res.clone().text(),\n        headers: Object.fromEntries(res.headers.entries()),\n        status: res.status,\n        time: Date.now(),\n      });\n    }\n\n    return res;\n  },\n  {\n    name: 'fetchWithCachedResponse',\n    attributesSuccess(result) {\n      return {\n        status: result.status,\n      };\n    },\n  },\n);\n"]}